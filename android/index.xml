<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Androids on QiHuan</title>
    <link>http://qihigh.github.io/android/</link>
    <description>Recent content in Androids on QiHuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Oct 2015 15:39:24 +0800</lastBuildDate>
    <atom:link href="http://qihigh.github.io/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>adb识别新的usb连接</title>
      <link>http://qihigh.github.io/android/usb_adb/</link>
      <pubDate>Mon, 26 Oct 2015 15:39:24 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/usb_adb/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;当有一个新的Android设备想要连接电脑时，如果识别不了，则需要主动将该设备的设备码id添加到abd_usb.ini的配置文件中。接下来介绍的是如何查找新设备的设备码。
&lt;pre&gt;
//mac下对应的命令
system_profiler SPUSBDataType &amp;gt; ~/usb.txt  &lt;/pre&gt;
打开文件usb.txt，在最后的&lt;code&gt;USB Hi-Speed Bus: -&amp;gt; Hub -&amp;gt; Android&lt;/code&gt;可以找到这个Android的条目，其中的&lt;code&gt;Vendor ID: 0x2a70&lt;/code&gt;就是对应的id，追加到&lt;code&gt;echo 0x2a70 &amp;gt;&amp;gt; ~/.android/adb_usb.ini&lt;/code&gt;中即可。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>尝试研究自己的flux架构</title>
      <link>http://qihigh.github.io/android/flux_study/</link>
      <pubDate>Mon, 26 Oct 2015 15:32:19 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/flux_study/</guid>
      <description>&lt;p&gt;###事件通知&lt;/p&gt;

&lt;p&gt;flux架构依赖于事件通知框架，这里使用的是EventBus，也可以采用otto。（如果不采用事件通知框架的话，会需要activity实现回调接口，这样的话侵入性较大，单元测试也不好写）&lt;/p&gt;

&lt;p&gt;研究eventBus的使用的时候，因为otto一般都是在onStart和onPause进行事件的注册和取消注册，但是在使用eventBus的时候发现，如果在onStart和onPause的时候进行事件注册，会丢失掉第一个事件，所以还是换成了onCreate和onDestory的时候进行事件的注册和取消注册。&lt;/p&gt;

&lt;p&gt;###store的可靠性&lt;/p&gt;

&lt;p&gt;flux架构依赖于store的数据可靠性，所以需要对有可能造成数据不可靠的情况进行特殊处理。一般的，这种情况容易出现在ListView显示的时候，store里的List集合被频繁更改导致的数据不同步。这里采用loadMore的方式，会触发数据集合的增长变化，来定位引发数据不同步的步骤，这里有两个值得怀疑的步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Api网络密集请求，在回调中频繁更新数据。&lt;/li&gt;
&lt;li&gt;事件通知框架有延迟，导致数据更新了而通知未到达。&lt;/li&gt;
&lt;li&gt;ListView中itemView渲染速度慢导致刷新问题（已验证，在View中添加耗时操作，界面卡顿，但不会出现异常）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过实际尝试，发现循环10次调用之后，步骤1会导致数据不同步，而步骤2没有出现异常。说明事件通知框架在数据密集请求的情况下是可靠地。&lt;/p&gt;

&lt;p&gt;###单元测试尝试&lt;/p&gt;

&lt;p&gt;flux架构一个特点就是方便测试，因为数据是单向的，事件的开始是调用action中的一个方法，最后一步数据的流向是通过EventBus来控制的，所以当做单元测试的时候，并不需要依赖activity，直接调用一个方法，然后注册一个Event监听，就能方便的完成单元测试。&lt;/p&gt;

&lt;p&gt;当然，由于数据有可能是网络请求，单元测试的过程中需要进行等待网络请求完成才能继续向下，这里采用了一个简单的锁机制，阻塞单元测试在网络请求完成之前不退出。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一种锁是AtomBoolean，是最初想到的方案，并且写在setUp和tearDown中，用起来很方便。&lt;/li&gt;
&lt;li&gt;现在采用的是BlockingQueue，这个是现在用的比较多的类，不过这里之所以采用他，是因为他和go语言中的锁机制是相同的，从大体上来看，更容易理解，使用起来比原子操作也简单。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;运行单元测试有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接在类的右键中运行单元测试，有特定的UI界面，比较友好，适合单个的单元测试。&lt;/li&gt;
&lt;li&gt;在命令行输入命令 &lt;code&gt;./gradlew connectedCheck&lt;/code&gt; ，适合运行所有单元测试。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>小米状态栏颜色</title>
      <link>http://qihigh.github.io/android/xiaomi_statusbar/</link>
      <pubDate>Mon, 26 Oct 2015 15:30:20 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/xiaomi_statusbar/</guid>
      <description>&lt;p&gt;小米的系统，最上方的状态栏是没有任何背景颜色的，当切换主题的时候就会遇到问题。当系统是白色的时候，如果切换到一个白色背景的主题，会导致上边状态栏的内容是分辨不出来的。（魅族的状态栏也没有颜色，但是他会根据当前背景，自动更新颜色，所以没有这个问题）&lt;/p&gt;

&lt;p&gt;这里通过反射的方式寻得了仅针对小米系统的一个解决方案:&lt;/p&gt;

&lt;pre&gt;
/**
 * 判断是否是小米，如果是的话，通过反射的方式，修改状态栏模式。
 * @param window
 */
public static void statusBar(Window window) {
    Boolean blackbg = Res.getBoolean(R.bool.isPop);
    Class clazz = window.getClass();
    try {
        int tranceFlag = 0;
        int darkModeFlag = 0;
        Class layoutParams = Class.forName(&#34;android.view.MiuiWindowManager$LayoutParams&#34;);

        Field field = layoutParams.getField(&#34;EXTRA_FLAG_STATUS_BAR_TRANSPARENT&#34;);
        tranceFlag = field.getInt(layoutParams);

        field = layoutParams.getField(&#34;EXTRA_FLAG_STATUS_BAR_DARK_MODE&#34;);
        darkModeFlag = field.getInt(layoutParams);

        Method extraFlagField = clazz.getMethod(&#34;setExtraFlags&#34;, int.class, int.class);

        extraFlagField.invoke(window, blackbg ? tranceFlag : darkModeFlag, blackbg ? tranceFlag : darkModeFlag);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>android start</title>
      <link>http://qihigh.github.io/android/start/</link>
      <pubDate>Mon, 26 Oct 2015 15:13:03 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/start/</guid>
      <description>&lt;p&gt;android相关&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>