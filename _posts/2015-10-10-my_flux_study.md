---
layout: post
title: "尝试研究自己的flux架构"
description: ""
category: 
tags: []
---
{% include JB/setup %}


###事件通知

flux架构依赖于事件通知框架，这里使用的是EventBus，也可以采用otto。（如果不采用事件通知框架的话，会需要activity实现回调接口，这样的话侵入性较大，单元测试也不好写）

研究eventBus的使用的时候，因为otto一般都是在onStart和onPause进行事件的注册和取消注册，但是在使用eventBus的时候发现，如果在onStart和onPause的时候进行事件注册，会丢失掉第一个事件，所以还是换成了onCreate和onDestory的时候进行事件的注册和取消注册。

###store的可靠性

flux架构依赖于store的数据可靠性，所以需要对有可能造成数据不可靠的情况进行特殊处理。一般的，这种情况容易出现在ListView显示的时候，store里的List集合被频繁更改导致的数据不同步。这里采用loadMore的方式，会触发数据集合的增长变化，来定位引发数据不同步的步骤，这里有两个值得怀疑的步骤：

 1. Api网络密集请求，在回调中频繁更新数据。
 2. 事件通知框架有延迟，导致数据更新了而通知未到达。
 3. ListView中itemView渲染速度慢导致刷新问题（已验证，在View中添加耗时操作，界面卡顿，但不会出现异常）

经过实际尝试，发现循环10次调用之后，步骤1会导致数据不同步，而步骤2没有出现异常。说明事件通知框架在数据密集请求的情况下是可靠地。


###单元测试尝试

flux架构一个特点就是方便测试，因为数据是单向的，事件的开始是调用action中的一个方法，最后一步数据的流向是通过EventBus来控制的，所以当做单元测试的时候，并不需要依赖activity，直接调用一个方法，然后注册一个Event监听，就能方便的完成单元测试。

当然，由于数据有可能是网络请求，单元测试的过程中需要进行等待网络请求完成才能继续向下，这里采用了一个简单的锁机制，阻塞单元测试在网络请求完成之前不退出。

1. 一种锁是AtomBoolean，是最初想到的方案，并且写在setUp和tearDown中，用起来很方便。
2. 现在采用的是BlockingQueue，这个是现在用的比较多的类，不过这里之所以采用他，是因为他和go语言中的锁机制是相同的，从大体上来看，更容易理解，使用起来比原子操作也简单。

运行单元测试有两种方式：

1. 直接在类的右键中运行单元测试，有特定的UI界面，比较友好，适合单个的单元测试。
2. 在命令行输入命令 ``` ./gradlew connectedCheck ``` ，适合运行所有单元测试。



