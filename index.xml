<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>齐欢的博客</title>
    <link>http://qihigh.github.io/</link>
    <description>Recent content on 齐欢的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_CN</language>
    <lastBuildDate>Thu, 05 Nov 2015 11:35:34 +0800</lastBuildDate>
    <atom:link href="http://qihigh.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>sina新接口问题</title>
      <link>http://qihigh.github.io/android/sina_new_api/</link>
      <pubDate>Thu, 05 Nov 2015 11:35:34 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/sina_new_api/</guid>
      <description>

&lt;h3 id=&#34;有问题的接口:39b0bd26443eb9e506e3b7b5698b2b2b&#34;&gt;有问题的接口&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;2/statuses/timeline_batch.json  没找到，我们在频道页需要使用，抓指定用户的微博timeline&lt;/li&gt;
&lt;li&gt;2/statuses/show_batch.json      没找到，我们在热门微博和热门话题里需要使用&lt;/li&gt;
&lt;li&gt;上传图片需要调整上传机制&lt;/li&gt;
&lt;li&gt;调整私信附件上传机制&lt;/li&gt;
&lt;li&gt;私信无法发送&lt;/li&gt;
&lt;li&gt;陌生人私信接口不一样，走的IM长连接&lt;/li&gt;
&lt;li&gt;2/friendships/friends/in_common.json   共同关注接口，没找到&lt;/li&gt;
&lt;li&gt;2/friendships/friends/bilateral.json   相互关注接口，没找到&lt;/li&gt;
&lt;li&gt;赞接口改为set_like, cancel_like, 参数未知&lt;/li&gt;
&lt;li&gt;无法更改用户头像&lt;/li&gt;
&lt;li&gt;2/account/profile/basic_update.json 无法更新用户信息&lt;/li&gt;
&lt;li&gt;2/place/pois/search.json接口不存在了，用2/place/nearby/pois，参数加q，传入keyword即可&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;处理中的接口:39b0bd26443eb9e506e3b7b5698b2b2b&#34;&gt;处理中的接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;checked&#34; disabled=&#34;true&#34;&gt; SearchApi &lt;/input&gt;&lt;/li&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;checked&#34; disabled=&#34;true&#34;&gt; UserApi &lt;/input&gt;&lt;/li&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;checked&#34; disabled=&#34;true&#34;&gt; MyAccountApi &lt;/input&gt;&lt;/li&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;checked&#34; disabled=&#34;true&#34;&gt; SuggestingApi  &lt;/input&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;checked&#34; disabled=&#34;true&#34;&gt; BatchTimeLineApi  &lt;/input&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里暂时使用的Gsid+srouceAppkey方式代替accessToken。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;checked&#34; disabled=&#34;true&#34;&gt; CommentApi &lt;/input&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;input type=&#34;checkbox&#34; disabled=&#34;false&#34;&gt; 发布评论、转发、微博 &lt;/input&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;特殊的，上传图片接口，发送多图的接口不对，暂时用gsid方式代替accessToken&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;waiting&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>gohttp搭建文件传输</title>
      <link>http://qihigh.github.io/back/gohttpserver/</link>
      <pubDate>Mon, 02 Nov 2015 18:02:03 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/gohttpserver/</guid>
      <description>

&lt;h3 id=&#34;搭建原因:1796173be1a42fe5f5a2b59aa2abedbc&#34;&gt;搭建原因&lt;/h3&gt;

&lt;p&gt;在服务器端用gohttp搭建快捷上传下载的服务，可以简化本地和服务器端传输文件过程中的复杂度。&lt;/p&gt;

&lt;p&gt;搭建文件服务之前，本地和服务器端文件传输都是通过ssh方式的scp进行拷贝，仅能通过命令行进行上传下载，颇为不方便。&lt;/p&gt;

&lt;p&gt;所以我一直在找一种可以方便的在服务器端和客户端进行文件传输的简便方式，最好是有界面的，毕竟这类操作图形界面会大大简便于命令行界面。&lt;/p&gt;

&lt;p&gt;曾经考虑过使用ftp服务器，但是这个搭建的时候出现了一些问题，而且ftp权限控制繁琐，搭建出来也并没有想象中的好使，下载问题解决了，上传问题仍然由于权限问题悬而未决。&lt;/p&gt;

&lt;p&gt;曾经想自己写一个服务器端的简单服务，用于通过http服务来做一个文件列表服务，就像php自带的文件列表一样，同时还要包含上传的功能，但最终由于时间问题还是尚未开始的状态。&lt;/p&gt;

&lt;p&gt;今天有幸遇到一个开发者，他在github上开源了一个这样的服务 &lt;a href=&#34;https://github.com/codeskyblue/gohttp&#34;&gt;gohttp&lt;/a&gt; ,并且比我想象的功能还要多，更关键的是他使用的go语言开发，最终的输出文件就一个可执行性文件，不需要复杂的服务器环境，简直是我等懒人福音。&lt;/p&gt;

&lt;p&gt;本地试了试，界面漂亮，执行起来也方便，于是准备直接用起来。&lt;/p&gt;

&lt;p&gt;接下来就介绍一下我搭建这个服务的流程。&lt;/p&gt;

&lt;h3 id=&#34;搭建过程:1796173be1a42fe5f5a2b59aa2abedbc&#34;&gt;搭建过程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先是登陆到服务器端&lt;/p&gt;

&lt;p&gt;服务器是linux，所以去下载一个linux端的可执行文件。
&lt;code&gt;
wget http://dn-gobuild5.qbox.me/gorelease/codeskyblue/gohttp/master/linux-amd64/gohttp.zip 
unzip gohttp.zip 
&lt;/code&gt;
得到文件 &lt;code&gt;gohttp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尝试运行&lt;/p&gt;

&lt;p&gt;执行命令 &lt;code&gt;gohttp --port 8000 --root .&lt;/code&gt; , 可以看到服务可以运行起来。
如果想校验的话，可以再开一个终端，请求一下这个服务 &lt;code&gt;wget 127.0.0.1:8000&lt;/code&gt; , 看看是否正确输出了文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使外网能够访问。&lt;/p&gt;

&lt;p&gt;一般的，直接将其本地ip更新为外网ip即可。但是这里用的是云服务器，云服务器一般只对外开放几个特定的端口，这里就需要一些特殊处理，一般的使用nginx来监听80端口，并分析域名并指向对应的服务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用nginx代理请求&lt;/p&gt;

&lt;p&gt;编辑nginx配置文件
&lt;pre&gt;
client_max_body_size 20m; // 配置能上传的最大文件大小
server {
        listen 80;
        server_name  files.weico.com;//指定访问的域名
        location / {
                proxy_pass &lt;a href=&#34;http://127.0.0.1:8000&#34;&gt;http://127.0.0.1:8000&lt;/a&gt;;
                proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        }
}
&lt;/pre&gt;
校验一下nginx的配置文件是否正确 &lt;code&gt;nginx -t&lt;/code&gt;,
校验ok之后，应用配置文件 &lt;code&gt;nginx -s reload&lt;/code&gt;。
此时通过 &lt;code&gt;files.weico.com&lt;/code&gt; 即可进行访问。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最终搭建的结果
&lt;img src=&#34;http://qihigh.github.io/images/QQ20151102-2.png&#34; alt=&#34;结果1&#34; /&gt;

&lt;img src=&#34;http://qihigh.github.io/images/QQ20151102-3.png&#34; alt=&#34;结果2&#34; /&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>阿里云后台尝试</title>
      <link>http://qihigh.github.io/back/aliyun/</link>
      <pubDate>Thu, 29 Oct 2015 16:36:17 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/aliyun/</guid>
      <description>

&lt;p&gt;今天尝试了一下阿里云，为了后期服务迁移到阿里云做准备。
需要做的事情:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 创建一个服务器
2. 设置ssh登陆
3. 运行一个基本的服务
4. 安装nginx，mysql，redis
5. 运行一个python的程序
6. 运行一个go的程序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了接下来介绍一下尝试的过程。&lt;/p&gt;

&lt;h3 id=&#34;申请账号:dbfe7d96810df03758892b85f573ce8c&#34;&gt;申请账号&lt;/h3&gt;

&lt;p&gt;这里使用的是 773731391@qq.com 的邮箱，登陆之后需要绑定支付宝进行实名认证。&lt;/p&gt;

&lt;p&gt;认证完成之后，有15天得试用期，然后选择建立云服务器。&lt;/p&gt;

&lt;h3 id=&#34;选择服务器:dbfe7d96810df03758892b85f573ce8c&#34;&gt;选择服务器&lt;/h3&gt;

&lt;p&gt;这里服务器有两种，一种是云引擎ACE，大致和SAE、BAE差不多，主要是面向的博客用户，他提供的是各种服务，用户不会直面服务器的复杂配置，这里当然不适合我。还有一种是云服务器ECS，这种是直接分配一个服务器给用户，可以选择系统，进行软件的安装和配置，这种自由度较高，当然费用也比较高，用起来和自己的服务器似的，这里选择这种服务器。&lt;/p&gt;

&lt;p&gt;新建一个服务器，操作系统选择Ubuntu14 64G，其他都选择默认的，内存1G，硬盘20G。完成之后，在云服务器列表中就可以看到新建的服务器了。&lt;/p&gt;

&lt;h3 id=&#34;云服务web管理:dbfe7d96810df03758892b85f573ce8c&#34;&gt;云服务web管理&lt;/h3&gt;

&lt;p&gt;web管理端提供了服务器的简单管理功能。&lt;/p&gt;

&lt;p&gt;现在在实例列表中可以看到有一个实例，实例ID是随机生成的，IP地址有一个内网Ip和外网Ip，还有服务器的运行状态，在更多中，可以看到连接管理终端，这里是在浏览器端建立一个长连接，连接到服务器的console控制台，第一次连接需要设置一个密码（这个密码并不是服务器端的密码）。&lt;/p&gt;

&lt;p&gt;服务器的关闭和重启也是在web管理端完成的。&lt;/p&gt;

&lt;p&gt;在管理中，更新服务器端的密码，初始密码肯定是要换的。然后就可以通过ssh的方式登录到远程服务器。&lt;/p&gt;

&lt;h3 id=&#34;登陆到服务器:dbfe7d96810df03758892b85f573ce8c&#34;&gt;登陆到服务器&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ssh root@112.126.74.74&lt;/code&gt; (这里是服务器的外网IP) 输入密码，即可完成登陆。&lt;/p&gt;

&lt;p&gt;这里由于ssh登陆还需要密码，固第一步先将自己本机的sshkey添加到服务器上.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~
mkdir .ssh
cd .ssh
echo &amp;quot;我的sshkey&amp;quot; &amp;gt;&amp;gt; authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后断开连接，重新使用ssh登陆，发现不再提示输入密码。完成ssh登陆的设置。&lt;/p&gt;

&lt;h3 id=&#34;安装amh服务:dbfe7d96810df03758892b85f573ce8c&#34;&gt;安装AMH服务&lt;/h3&gt;

&lt;p&gt;接下来安装一个AMH的php服务，这里集成了很多东西:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务器的管理&lt;/li&gt;
&lt;li&gt;mysql、php、ftp、nginx的安装和默认配置&lt;/li&gt;
&lt;li&gt;mysql的管理界面（类似php）&lt;/li&gt;
&lt;li&gt;方便的建站功能。&lt;/li&gt;
&lt;li&gt;其他功能详细参见  (网站)[&lt;a href=&#34;http://bbs.aliyun.com/read/143639.html?spm=5176.bbsr253866.0.0.Ppby9K&#34;&gt;http://bbs.aliyun.com/read/143639.html?spm=5176.bbsr253866.0.0.Ppby9K&lt;/a&gt;]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装的过程就是下载一个脚本，然后执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://amh.sh/file/AMH/4.2/amh.sh &amp;amp;&amp;amp; chmod 775 amh.sh &amp;amp;&amp;amp; ./amh.sh 2&amp;gt;&amp;amp;1 | tee amh.log&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装过程中会提示输入系统密码和mysql数据库的密码。&lt;/p&gt;

&lt;h4 id=&#34;安装过程中遇到问题-php安装失败:dbfe7d96810df03758892b85f573ce8c&#34;&gt;安装过程中遇到问题，php安装失败。&lt;/h4&gt;

&lt;p&gt;提示的异常信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -xf ams-1.5.0107-02.tar.gz ing...
[OK] ams-1.5.0107-02 install completed.
Sorry, Failed to install AMH
Please contact us: http://amh.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但实际上这里并没有提供出有用的信息，将日志向上查看，发现是php的安装失败导致的失败。&lt;/p&gt;

&lt;p&gt;主要就是php依赖的一个库没有正常安装上（这个废了好大力气才确认这个库）。首先找到AMH安装过程中软件包得下载地址和解压地址。AMH安装过程中会建立一个用户，文件会放在这个用户下，安装完成之后这个用户和文件都会被删掉。这个账户下找到各个软件的安装目录，主要是php的安装目录。重新执行一遍php的安装过程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure 。。。此处省略n多配置
make 
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行的过程中发现异常信息，
&lt;code&gt;Compile fails &amp;quot;configure: error: Please reinstall the iconv library&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也就是说 &lt;code&gt;/usr/local/libiconv&lt;/code&gt; 这个库安装失败了，导致的php安装失败。之后在php目录的上一级目录，也就是AMH的安装包目录下发现有这个库，于是重新安装一下这个库。&lt;/p&gt;

&lt;p&gt;安装的过程中曝出了具体的错误信息，google了一下，网上说是源码有问题，（源码找不到了，这里就不贴了暂时）遂去修改源码并重新编译安装，完成。之后重新运行AMH的安装脚本（AMH的安装脚本中包含了php的编译和安装，就不需要自己手工去编译安装了）&lt;/p&gt;

&lt;p&gt;之后AMH顺利安装完成。访问 &lt;code&gt;112.126.74.74:8888&lt;/code&gt; 打开AMH的登录页面。&lt;/p&gt;

&lt;h3 id=&#34;登录后台-查看各个服务:dbfe7d96810df03758892b85f573ce8c&#34;&gt;登录后台，查看各个服务&lt;/h3&gt;

&lt;p&gt;nginx -t 发现服务正常运行着。
mysql -uroot -p 然后输入密码，正常登录。
通过AMH管理页面，可以清楚的看到当前服务器的CPU使用状态等等信息。&lt;/p&gt;

&lt;p&gt;通过AMH建立一个站点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;添加一个虚拟主机 （也就是一个php服务站）&lt;/li&gt;
&lt;li&gt;添加FTP，FTP的根目录指向刚刚新建的虚拟主机根目录。&lt;/li&gt;
&lt;li&gt;通过快速建库新建一个mysql数据库&lt;/li&gt;
&lt;li&gt;模块扩展中有一个AMFTP，激活这个模块，就可以通过web端进行FTP文件上传和下载了，非常方便（再也不用scp进行文件拷贝了，省事很多）&lt;/li&gt;
&lt;li&gt;进入服务器，看到刚刚的站点就在 /home/wwwroot/ 下，上传的文件也在对应的web目录下。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;数据库的管理:dbfe7d96810df03758892b85f573ce8c&#34;&gt;数据库的管理&lt;/h3&gt;

&lt;p&gt;非图形界面，自然就是mysql命令行了。&lt;/p&gt;

&lt;p&gt;数据库的管理部分，使用AMH提供的足够用了，使用上和phpmyadmin很像。当然也可以自己换成phpmyadmin。&lt;/p&gt;

&lt;p&gt;如果想通过本机的客户端管理数据库也是可以的,这里使用的是 &lt;code&gt;Navicat for MySql&lt;/code&gt;。由于mysql默认是不支持远程连接，只支持本地连接（最好不要开放外网连接），这里通过ssh的方式进行连接。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;新建一个连接，打开ssh选项卡，选中 &lt;code&gt;Use SSH tunnel&lt;/code&gt;,输入IP和密码（如果是ssh证书方式，可以指向整数文件）&lt;/li&gt;
&lt;li&gt;回到General中，ip填写 &lt;code&gt;127.0.0.1&lt;/code&gt; ，输入用户名和密码，点击 &lt;code&gt;Test Connection&lt;/code&gt; 校验是否连接成功.&lt;/li&gt;
&lt;li&gt;点击OK，完成连接&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过AMH快速建表的时候，实际上是可以指定该数据库是否支持外网的，在允许链接来源地址中填写&lt;code&gt;%&lt;/code&gt;，这样的话通过本地客户端可以直接连到数据库（用这里添加的用户名和密码，不是数据库本身的），不需要ssh登陆，不过连过去之后也只能看到这一个表。&lt;/p&gt;

&lt;h3 id=&#34;安装redis:dbfe7d96810df03758892b85f573ce8c&#34;&gt;安装redis&lt;/h3&gt;

&lt;p&gt;安装redis非常简单，直接去官网下载最新的tar包即可.redis官网地址：&lt;a href=&#34;http://www.redis.io/&#34;&gt;http://www.redis.io/&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt; $ wget http://download.redis.io/releases/redis-3.0.5.tar.gz
 $ tar xzf redis-3.0.5.tar.gz
 $ cd redis-3.0.5
 $ make
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编译完成之后，redis-server生成在src目录下。将目录下得 redis-server ,redis-cli,redis-benchmark, ../redis.conf 移到 &lt;code&gt;/usr/local/redis&lt;/code&gt; 下&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将目录 &lt;code&gt;/usr/local/redis&lt;/code&gt; 添加到环境变量中，echo &amp;ldquo;export PATH=$PATH:\&amp;ldquo;/usr/local/redis\&amp;ldquo;&amp;rdquo; &amp;gt;&amp;gt; .bash_profile ,并使其生效。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动redis-server &lt;code&gt;nohup redis-server redis.conf &amp;amp;&lt;/code&gt; ,然后通过 redis-cli 进行测试服务是否正常启动&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;安装python相关模块:dbfe7d96810df03758892b85f573ce8c&#34;&gt;安装python相关模块&lt;/h3&gt;

&lt;p&gt;安装的时候，需要两个python的工具，pip和virtualenv，通过apt-get 进行安装即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtualenv virtual
cd virtual
./bin/pip install futures
./bin/pip install tornado
./bin/pip install oursql
./bin/pip install DBUtils
./bin/pip install nose
./bin/pip install apscheduler
./bin/pip install BeautifulSoup
./bin/pip install qiniu==6.1.9
./bin/pip install PIL
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;安装python的oursql模块时-遇到问题:dbfe7d96810df03758892b85f573ce8c&#34;&gt;安装python的oursql模块时，遇到问题：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;报错信息: &lt;code&gt;tornado/speedups.c:2:20: fatal error: Python.h: No such file or directory
#include &amp;lt;Python.h&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指python的开发版本是需要的 apt-get install python-dev&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行&lt;code&gt;sudo pip install oursql&lt;/code&gt;,再次报错: &lt;code&gt;oursqlx/compat.h:13:19: fatal error: mysql.h: No such file or directory
#include &amp;quot;mysql.h&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指oursql编译的时候，依赖的本地so文件不存在，需要进行安装：
&lt;code&gt;sudo apt-get install libmysqlcppconn-dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install libmysqlclient-dev&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再次执行&lt;code&gt;sudo pip install oursql&lt;/code&gt; ,打出一些警告信息，安装成功。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>本地图片加载方案(强化picasso)</title>
      <link>http://qihigh.github.io/android/myLocalImageLoader/</link>
      <pubDate>Tue, 27 Oct 2015 18:01:38 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/myLocalImageLoader/</guid>
      <description>&lt;p&gt;由于最新的picasso加载本地图片时，如果图片是相机直接拍摄的，一般尺寸会非常大，picasso处理不了这样的大图。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Glide应该可以处理,没有尝试.&lt;/li&gt;
&lt;li&gt;Ion应该是可以的.&lt;/li&gt;
&lt;li&gt;Facebook 的 Fresco 是可以的.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里不想因为这个问题就换掉整个picasso，然后就打算自己写一个。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.squareup.picasso;

import android.graphics.Bitmap;
import android.media.ThumbnailUtils;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.support.v4.util.LruCache;
import android.text.TextUtils;
import android.widget.ImageView;

import com.eico.weico.WApplication;
import com.eico.weico.utility.BitmapUtil;

import java.util.concurrent.ExecutorService;

/**
 * Created by qihuan on 15/10/27.
 */
public class MyLoadFileLoader {
    private static MyLoadFileLoader instance;
    //线程池
    private final ExecutorService threadPool;
    //内存缓存
    private final LruCache&amp;lt;String, Bitmap&amp;gt; cache;

    static {
        instance = new MyLoadFileLoader();
    }


    private MyLoadFileLoader() {
        threadPool = WApplication.cThreadPool;
        cache = new LruCache(50);
    }

    public static MyLoadFileLoader getInstance() {
        return instance;
    }

    /**
     * 触发加载
     * 1. 缓存中有，直接从缓存中获取
     * 2. 缓存中没有，读取图片，并采用ThumbUtil进行方图裁切。
     *
     * @param aPath     本地图片路径
     * @param aSize     最终显示的大小（仅支持方图）
     * @param aResId    placeholder
     * @param imageView 目标imageView
     */
    public void load(final String aPath, final int aSize, int aResId, final ImageView imageView) {
        if (TextUtils.isEmpty(aPath)) {
            //失败默认使用resId
            if (aResId &amp;gt; 0) {
                imageView.setImageResource(aResId);
            }
            return;
        }
        //防止图片串位
        imageView.setTag(aPath);
        //缓存处理
        Bitmap cachedBitmap = cache.get(aPath);
        if (null != cachedBitmap) {
            imageView.setImageBitmap(cachedBitmap);
            return;
        }

        //placeholder
        if (aResId &amp;gt; 0) {
            imageView.setImageResource(aResId);
        }

        final Bitmap[] bitmaps = new Bitmap[1];

        //回归UI线程处理
        final Handler handler = new Handler(Looper.getMainLooper(), new Handler.Callback() {
            @Override
            public boolean handleMessage(Message msg) {
                if (aPath.equals(imageView.getTag()) &amp;amp;&amp;amp; null != bitmaps[0]) {
                    imageView.setImageBitmap(bitmaps[0]);
                }
                return false;
            }
        });

        //本地读取裁切任务，添加到线程池
        threadPool.submit(new Runnable() {
            @Override
            public void run() {
                Bitmap source = BitmapUtil.decodeBitmap(aPath, 200);
                Bitmap temp = ThumbnailUtils.extractThumbnail(source, aSize, aSize);
                if (null != temp &amp;amp;&amp;amp; temp.getWidth() &amp;gt; 0) {
                    //图片添加到缓存，通知UI线程更新
                    bitmaps[0] = temp;
                    handler.sendEmptyMessage(0);
                    cache.put(aPath, temp);
                }
            }
        });

    }

}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>picasso滑动暂停加载</title>
      <link>http://qihigh.github.io/android/picasso/</link>
      <pubDate>Tue, 27 Oct 2015 11:20:35 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/picasso/</guid>
      <description>&lt;p&gt;需要在滑动的listView中进行监听，这里有两个listener，一个是针对listView的，一个是针对RecyclerView的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.squareup.picasso;

import android.content.Context;
import android.widget.AbsListView;

public class SampleScrollListener implements AbsListView.OnScrollListener {
    private final Context context;
    private static final Object scrollTag = new Object(); // this can be static or not, depending what u want to achieve

    public SampleScrollListener(Context context) {
        this.context = context;
    }

    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {
        final Picasso picasso = Picasso.with(context);
        if (scrollState == SCROLL_STATE_IDLE || scrollState == SCROLL_STATE_TOUCH_SCROLL) {
            picasso.resumeTag(scrollTag);
        } else {
            picasso.pauseTag(scrollTag);
        }
    }

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
                         int totalItemCount) {
        // Do nothing.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package com.ewintory.udacity.popularmovies.utils;


import android.content.Context;
import android.support.v7.widget.RecyclerView;


import com.squareup.picasso.Picasso;
import com.squareup.picasso.RequestCreator;


/**
 * Simple {@link RecyclerView.OnScrollListener} implementation which
 * pauses/resumes Picasso&#39;s tagged requests
 *
 * @author Emin Yahyayev
 * @see {@link RequestCreator#tag(Object)}
 */
public final class PicassoScrollListener extends RecyclerView.OnScrollListener {


    private static final int DEFAULT_SENSITIVITY = 120;


    private Picasso mPicasso;
    private int mPauseSensitivity; // scroll sensitivity
    private Object mTag;


    public PicassoScrollListener(Context context, Object tag) {
        this(Picasso.with(context), tag, DEFAULT_SENSITIVITY);
    }


    public PicassoScrollListener(Picasso picasso, Object tag) {
        this(picasso, tag, DEFAULT_SENSITIVITY);
    }


    public PicassoScrollListener(Context context, Object tag, int pauseSensitivity) {
        this(Picasso.with(context), tag, pauseSensitivity);
    }


    public PicassoScrollListener(Picasso picasso, Object tag, int pauseSensitivity) {
        mPicasso = picasso;
        mPauseSensitivity = pauseSensitivity;
        mTag = tag;
    }


    @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
        if (Math.abs(dy) &amp;gt; mPauseSensitivity)
            mPicasso.pauseTag(mTag);
        else
            mPicasso.resumeTag(mTag);
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>后端交接文档</title>
      <link>http://qihigh.github.io/back/backyield/</link>
      <pubDate>Mon, 26 Oct 2015 15:40:55 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/backyield/</guid>
      <description>&lt;pre&gt;

账号：

1、监控宝
http://www.jiankongbao.com

weicolomo@gmail.com     weico+lomo  -&gt; weico+lomo_
canon@3ciyuan.com     xinciyuan123【已弃用】
dev@weico.com       kUBZiiwEh3Bie8   -&gt; kUBZiiwEh3Bie8_

2、snmp v3（所有机器）
weico     8899//==we

3、UCloud
dev@eicodesign.com
dev@5YxbNTdbMP  -&gt; dev@5YxbNTdbMP_

更新为
    qihuan@weico.com
    weico2014++

4、DNSPod
info@eicodesign.com  // weico.com weico.net
9ol.=[;.        -&gt; 9ol.=[;._
weico@eicodesign.com // weico.cc weicopl.us
9ol.=[;.        -&gt; 9ol.=[;._
likan@eicodesign.com
9ol.=[;.        -&gt; 9ol.=[;.=

5、花生壳
weicodev/1q2w3e4r  -&gt; 1q2w3e4r_
                   -&gt; 1q2w3e4r

6 Linode    --- 
用户名: 1982870, 密码: 1982870123a
ssh root@106.185.52.238 -p 1010
Cec+Pav&gt;kelv&gt;iD%

7 Jenkins
http://weicodev.wicp.net:9090/
http://192.168.1.80:8080/
username: weico
password: fU$ij+Mod:aD]jaR

8 weico.com邮箱管理帐号
ym.163.com
admin@weico.com / OLuJRaDe51qQ  //error password

9. WeicoBUG跟踪系统

http://192.168.1.80/bugzilla/ （内网）
http://weicodev.wicp.net:8080/bugzilla/
dev@weico.com
1123581321

10. 七牛云存储 / ucloud
    dev@weico.com
    密码 weico2014++


联系方式：

800083103     广东锐讯网络有限公司
1171533501     森华 销售 看丹桥-梁爽
938060261      森华 看丹桥
712957909     美国机房
2880269152     锐讯-周鸿升
609509091     李侃推荐 服务器-DELL-聂伟


服务器列表：

ssh deployer@42.62.2.50 - 
主要是weico的好友数据库，以及postgres地理位置数据，基本不用特别维护

ssh deployer@42.62.2.51 - 
1. 新的小游戏平台weicogame服务（包括后端API以及前端服务）
2. 方糖相机资源管理API服务
3. 方糖相机，下载跳转jumper服务
4. 方糖相机用户数据上报服务
5. meShot资源管理 ResourceManager

ssh deployer@42.62.2.58  - 
1. 微可拍API /home/deployer/developer/weicoplus (编译后的)
2. Pinco服务
3. Pinco的Tag搜索服务
4. weico api服务

ssh deployer@42.62.2.59  - 
1. 微可拍粉丝数据SSDB

ssh deployer@42.62.2.60 -
1. 文件存储服务器

ssh deployer@42.62.2.61 -
1. 微可拍好友动态数据SSDB

ssh deployer@42.62.2.62 -
1. weico3 数据库

ssh weico3@42.62.2.62
1. weico3 服务 (ssh weico3@42.62.2.62)
     文件位置：/mnt/tfs7/weico3/go/src/com.weico/weico3 
     项目地址：git@weicodev.vicp.cc:/mnt/data/repo/weico_server_go_v3.git

ssh deployer@118.26.233.56 -
1. 微可拍老接口 （/home/deployer/project/weicolomo/）
2. 微可拍用户接口 （/home/deployer/project/profile/）
3. 微可拍接口 （/home/deployer/androidtest/weicolomo）
4. 微可拍辅库
5. Redis服务（weico_user_q定时删除）

ssh deployer@118.26.233.57
1. 微可拍主库

ssh deployer@118.26.225.125
1. weico.com/eicodesign.com等官网
2. 数据库访问 mysql -h 127.0.0.1 -uroot
3. eico的用户管理erp http://118.26.225.125:8087/

ssh deployer@119.147.137.69
ssh deployer@119.90.40.250

ssh ubuntu@120.132.54.51
1. weiconote国内服务器
su: note@weico2014++
 ip更新为 120.132.56.18
 sudo weico2014++
 sudo -i 切换为root用户

ssh deployer@106.185.52.238 -p 1010
1. weiconote海外服务器地址（oversea, japan, korean）
     项目路径 /home/deployer/developer/workspace/src/com.weico
2. redis服務 redis-cli
3. mysql服务 mysql -uroot -proot




常见错误处理：
1. 服务器硬盘快满了
cd /usr/local/nginx/logs/  或者
cd /usr/local/tengine/logs
cp /dev/null 比较大的日志.log

2. 118.26.233.56 的mysql主从备份出错
https://alexzeng.wordpress.com/2013/10/17/how-to-fix-mysql-slave-after-relay-log-corrupted/

mysql -uroot -proot

show slave status\G;

stop slave;

CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000737&#39;, MASTER_LOG_POS=625032890;

start slave;

3. weico+服务无法访问，先查看42.62.2.58上的10010端口的revel 服务是否正常运行，没有则运行 revel run com.weico/weicoplus prod 10010
如果服务正常运行，则查看是不是日志满了

4.  42.62.2.51服务器添加服务端口
     firewall-cmd --permanent --zone=public --add-port=10020/tcp
     firewall-cmd --reload


5. 海蜘蛛路由器密码
    路由器管理地址：http://10.0.1.254:880/
    管理页面登陆账号:admin - r3i2ojS_dcjir4f
    路由器拨号账号：
        1. 010010017063 - 731792
        2. 010999009413  - 暂未重置

&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>DNS域名绑定</title>
      <link>http://qihigh.github.io/back/dns_bind/</link>
      <pubDate>Mon, 26 Oct 2015 15:40:23 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/dns_bind/</guid>
      <description>

&lt;p&gt;首先域名绑定需要的几个基础概念:&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;a-address-记录:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;A(Address)记录&lt;/h4&gt;

&lt;p&gt;是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。&lt;/p&gt;

&lt;h4 id=&#34;cname:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;CNAME&lt;/h4&gt;

&lt;p&gt;也被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。 这两个别名的全称就是“www.mydomain.com”和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。 同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP然后将其他的域名做别名到之前做A记录的域名上，那么当您的服务器IP地址变更时您就可以不必麻烦的一个一个域名更改指向了 只需要更改做A记录的那个域名其他做别名的那些域名的指向也将自动更改到新的IP地址上了。&lt;/p&gt;

&lt;h4 id=&#34;ttl:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;TTL&lt;/h4&gt;

&lt;p&gt;TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间。要理解TTL值，请先看下面的一个例子： 假设，有这样一个域名myhost.cnMonkey.com（其实，这就是一条DNS记录，通常表示在abc.com域中有一台名为myhost的主机）对应IP地 址为1.1.1.1，它的TTL为10分钟。这个域名或称这条记录存储在一台名为dns.cnMonkey.com的DNS服务器上。 现在有一个用户键入一下地址（又称URL）：&lt;a href=&#34;http://myhost.cnMonkey.com&#34;&gt;http://myhost.cnMonkey.com&lt;/a&gt; 这时会发生什么呢？ 该 访问者指定的DNS服务器（或是他的ISP,互联网服务商, 动态分配给他的)8.8.8.8就会试图为他解释myhost.cnMonkey.com，当然8.8.8.8这台DNS服务器由于没有包含 myhost.cnMonkey.com这条信息，因此无法立即解析，但是通过全球DNS的递归查询后，最终定位到dns.cnMonkey.com这台DNS服务器， dns.cnMonkey.com这台DNS服务器将myhost.cnMonkey.com对应的IP地址1.1.1.1告诉8.8.8.8这台DNS服务器，然有再由 8.8.8.8告诉用户结果。8.8.8.8为了以后加快对myhost.cnMonkey.com这条记录的解析，就将刚才的1.1.1.1结果保留一段时间，这 就是TTL时间，在这段时间内如果用户又有对myhost.cnMonkey.com这条记录的解析请求，它就直接告诉用户1.1.1.1，当TTL到期则又会重复 上面的过程。&lt;/p&gt;

&lt;h4 id=&#34;域名分级:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;域名分级&lt;/h4&gt;

&lt;p&gt;子域名是个相对的概念，是相对父域名来说的。域名有很多级，中间用点分开。例如中国国家顶级域名CN，所有以 CN 结尾的域名便都是它的子域。例如：www.zzy.cn 便是 zzy.cn 的子域，而 zzy.cn 是 cn 的子域。&lt;/p&gt;

&lt;p&gt;“二级域名”：目前有很多用户认为“二级域名”是自己所注册域名的下一级域名，实际上这里所谓的“二级域名”并非真正的“二级”，而应该称为“次级”(相对次级)&lt;/p&gt;

&lt;p&gt;例如您注册的域名是abc.cn来说：CN为顶级域，abc.cn为二级域，www.abc.cn、mail.abc.cn、help.zzy.cn为三级域。&lt;/p&gt;

&lt;p&gt;还有一些特殊的二级域被用来作顶级域使用，例如：com.cn、net.cn、org.cn、gov.cn（包括地区域名bj.cn、fj.cn等）。那么此时用户所注册的就应该是三级域了，例如114.com.cn。（备注：www.gov.cn实际上是以gov.cn为后缀的www域名，就是说如果您在域名Whois信息查询中输入gov.cn是查询不到注册信息的因为gov.cn是作为顶级域来使用的域名后缀，真正开放注册的是www.gov.cn）。然而当前有很多用户还是习惯地将可以允许用户注册的域名称为顶级域名，而所注册域名的下一级域名称为“二级域名”，其实从严格意义上来讲这是不对的，所以我们前面会说“子域名”、“二级域名”是相对的概念，准确的应该称为“次级域名”。&lt;/p&gt;

&lt;h4 id=&#34;域名购买:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;域名购买&lt;/h4&gt;

&lt;p&gt;众所周知，域名是要购买的，国内用域名访问主机大概是要备案的，有些麻烦。所以现在很多人从国外的域名注册商那儿买域名，比如goddady。如果是新手想在国外买域名的话，最好准备一张VISA信用卡，并用paypal来支付（可以省手续费）。goddady现在也支持支付宝，支付起来也很方便。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;接下来介绍weico在DNSPod上购买的域名处理方式。
在weico.cc域名下得记录管理中，有添加的很多记录，这里首先是默认的三个@记录，这是默认的记录，不用管。
接下来列表中还有很多，比如abc对应的记录：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主机记录:abc    &amp;ndash;表示的是主机的三级域名&lt;/li&gt;
&lt;li&gt;记录类型:A    &amp;ndash;表示的是A类记录&lt;/li&gt;
&lt;li&gt;线路类型:默认   &amp;ndash;这里也包含海外和国内&lt;/li&gt;
&lt;li&gt;记录值:42.62.2.51    &amp;ndash;域名对应的ip地址&lt;/li&gt;
&lt;li&gt;TTl:120       &amp;ndash;过期时间，这里是两分钟&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这里，尝试ping 42.62.2.51 是可以ping通的，abc加上二级域名weico.cc，组成abc.weico.cc，这个应该也是可以ping通的。&lt;/p&gt;

&lt;p&gt;印证一下
uploadify的地址是 &lt;a href=&#34;http://118.26.225.125:8006/index，&#34;&gt;http://118.26.225.125:8006/index，&lt;/a&gt;
在记录值中找到对应这个ip的有几条记录，这里选用weicofile这个三级域名，将地址更新为 &lt;a href=&#34;http://weicofile.weico.cc:8006/index，&#34;&gt;http://weicofile.weico.cc:8006/index，&lt;/a&gt; 发现访问的结果是相同的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>adb识别新的usb连接</title>
      <link>http://qihigh.github.io/android/usb_adb/</link>
      <pubDate>Mon, 26 Oct 2015 15:39:24 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/usb_adb/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;当有一个新的Android设备想要连接电脑时，如果识别不了，则需要主动将该设备的设备码id添加到abd_usb.ini的配置文件中。接下来介绍的是如何查找新设备的设备码。
&lt;pre&gt;
//mac下对应的命令
system_profiler SPUSBDataType &amp;gt; ~/usb.txt  &lt;/pre&gt;
打开文件usb.txt，在最后的&lt;code&gt;USB Hi-Speed Bus: -&amp;gt; Hub -&amp;gt; Android&lt;/code&gt;可以找到这个Android的条目，其中的&lt;code&gt;Vendor ID: 0x2a70&lt;/code&gt;就是对应的id，追加到&lt;code&gt;echo 0x2a70 &amp;gt;&amp;gt; ~/.android/adb_usb.ini&lt;/code&gt;中即可。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>blog生成命令相关</title>
      <link>http://qihigh.github.io/back/blog_generate/</link>
      <pubDate>Mon, 26 Oct 2015 15:34:59 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/blog_generate/</guid>
      <description>

&lt;h3 id=&#34;jekyll-方式:53ce08bd8daefb24173b0a5b1246e436&#34;&gt;jekyll 方式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新建一篇可以进行评论的文章&lt;code&gt;rake post title=&amp;quot;nginx study&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行blog的命令
&lt;code&gt;
    jekyll serve
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hugo-方式:53ce08bd8daefb24173b0a5b1246e436&#34;&gt;hugo 方式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新建一个侧边栏&lt;/p&gt;

&lt;p&gt;在config.yaml中添加一个新的links就可以&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新建一篇文章&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new android/new.md&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行服务&lt;/p&gt;

&lt;p&gt;实时更新方式（当进行修改之后，后台会发通知给浏览器，浏览器自动更新，不需要手动刷新）
&lt;code&gt;hugo server --theme=herring-cove --buildDrafts --watch&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;阿里云服务器:53ce08bd8daefb24173b0a5b1246e436&#34;&gt;阿里云服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;网页控制台登陆密码 qihuan
服务器端密码 2wsx3EDC
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>学习nginx的安装、配置</title>
      <link>http://qihigh.github.io/back/nginx_study/</link>
      <pubDate>Mon, 26 Oct 2015 15:34:15 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/nginx_study/</guid>
      <description>

&lt;h4 id=&#34;nginx的本地安装:1da1b7d5c01ab3bac077892a9b3f8ca3&#34;&gt;nginx的本地安装&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先是要在本地安装一个nginx服务器，来看看最基本的nginx是神马样子的。安装方式并不复杂，而且nginx完全是通过c来编写的，依赖并不多，整个服务器才不到1Mb。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;特殊的，nginx是有很多第三方包的，而且实际调试使用时基本是必须的，如果一个一个安装显得过于繁琐，这里有一个配置好了各个常用插件的nginx的版本：openresty,下载下来进行安装即可。mac下需要首先安装&lt;code&gt;PCRE&lt;/code&gt;，然后通过
&lt;pre&gt;
$ ./configure \
         &amp;ndash;with-cc-opt=&amp;ldquo;-I/usr/local/include&amp;rdquo; \
         &amp;ndash;with-ld-opt=&amp;ldquo;-L/usr/local/lib&amp;rdquo; \ &lt;/pre&gt;
进行配置，然后通过&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt; 进行安装&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;本地运行环境是mac，需要安装一个perl的正则解析PCRE
&lt;pre&gt;
$ cd ~/Downloads
$ tar xvzf pcre-8.5
$ cd pcre-8.5
$ sudo ./configure &amp;ndash;prefix=/usr/local
$ sudo make
$ sudo make install &lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后安装nginx
&lt;pre&gt;
$ cd ~/Downloads
$ tar xvzf nginx-1.6.0.tar.gz
$ cd nginx-1.6.0
$ sudo ./configure &amp;ndash;prefix=/usr/local/nginx &amp;ndash;with-http_ssl_module &amp;ndash;with-cc-opt=&amp;ldquo;-Wno-deprecated-declarations&amp;rdquo;
$ sudo make
$ sudo make install &lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尝试启动nginx，
&lt;pre&gt;
$ cd /usr/local/nginx/sbin
$ sudo ./nginx  &lt;/pre&gt;
然后访问&lt;code&gt;localhost&lt;/code&gt;,如果页面显示&lt;code&gt;Welcome to nginx!&lt;/code&gt;,则说明nginx安装成功并成功启动。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;停止nginx
&lt;pre&gt;
sudo ./nginx -s stop    &lt;/pre&gt;
之后可以将nginx加入到path中去。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果nginx停止失败，可以通过kill命令来通知nginx停止&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先查看nginx运行的情况 &lt;code&gt;ps -ef|grep nginx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找到master进程，它的编号就是主进程号了，通过 &lt;code&gt;sudo kill -QUIT 8339 将其杀掉&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改了配置文件，首先校验配置文件是否正确
&lt;pre&gt;
nginx -t -c nginx.conf
或者
nginx -t &lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不重启nginx，应用新的配置文件.（首先要使用步骤7校验配置文件）
&lt;pre&gt;
nginx -s reload &lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Mysql导出表结构及表数据 mysqldump用法</title>
      <link>http://qihigh.github.io/back/mysql_dump/</link>
      <pubDate>Mon, 26 Oct 2015 15:33:46 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/mysql_dump/</guid>
      <description>

&lt;h4 id=&#34;命令行下具体用法如下:21b917757f8ba675c9e9b05b2ed32895&#34;&gt;命令行下具体用法如下：&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;mysqldump -u用戶名 -p密码 -d 数据库名 表名 脚本名;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;导出数据库為dbname的表结构（其中用戶名為root,密码為dbpasswd,生成的脚本名為db.sql）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysqldump -uroot -pdbpasswd -d dbname &amp;gt;db.sql;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导出数据库為dbname某张表(test)结构&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysqldump -uroot -pdbpasswd -d dbname test&amp;gt;db.sql;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导出数据库為dbname所有表结构及表數據（不加-d）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysqldump -uroot -pdbpasswd  dbname &amp;gt;db.sql;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导出数据库為dbname某张表(test)结构及表數據（不加-d）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysqldump -uroot -pdbpasswd dbname test&amp;gt;db.sql;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;其他数据库相关:21b917757f8ba675c9e9b05b2ed32895&#34;&gt;其他数据库相关&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;查看MySQL端口号：```show global variables like &#39;port&#39;;  ```
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>后台经验</title>
      <link>http://qihigh.github.io/back/yield_experience/</link>
      <pubDate>Mon, 26 Oct 2015 15:33:12 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/yield_experience/</guid>
      <description>

&lt;p&gt;###ssh
使用天宇发过来的rsa进行登录
&lt;code&gt;ssh -i ~/.ssh/weico_rsa root@xxx.xxx.xxx.xxx&lt;/code&gt;
chmod 600 weico_rsa 你要改下权限&lt;/p&gt;

&lt;p&gt;###服务器
1.  Linode&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ssh -i ~/workspace/weico_rsa root@106.185.52.238 -p 1010&lt;/code&gt;
        weiconote海外&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###工具&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;压缩命令 tar&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;压缩muma_web，文件名为web.tar.gz，压缩方式为gzip
&lt;code&gt;tar -czvf web.tar.gz muma_web&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;复制命令&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本地到远程
&lt;code&gt;
scp -i ~/workspace/weico_rsa temp.txt deployer@42.62.2.58:/home/deployer/temp.txt
&lt;/code&gt;
颠倒一下 远程到本地
&lt;code&gt;
scp -i ~/workspace/weico_rsa deployer@42.62.2.58:/home/deployer/temp.txt 1.txt
&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ssh服务器端&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;弄个ssh-copy-id
&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub user@server&lt;/code&gt;
类似这样，把你的key全部加一下&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ps查看所有用户运行的程序，和top类似，但是只查看一瞬间&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;
[weico3@localhost project]$ ps aux|grep deployer
deployer  5786  0.0  0.0 108460  1008 pts/2    Ss+  Jul06   0:00 -bash
deployer  6427  0.0  0.0  28916  1256 ?        Ss   Mar09  68:08 tmux new -s devel
deployer  6428  0.0  0.0 108460     0 pts/7    Ss   Mar09   0:00 -bash
deployer  6445  0.0  0.0 199840   104 pts/7    S+   Mar09   0:00 mysql -uroot
weico3   13004  0.0  0.0 103260   592 pts/1    S+   15:50   0:00 grep deployer
    &lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mysql -uroot -p是什么命令&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个是登mysql登陆数据库的命令，如果你使用黑窗口(DOS)的话就要这个命令进入数据库。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ll 命令&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ll 命令列出的信息更加详细，有时间，是否可读写等信息 , 和ls相比，ll会列出该文件下的所有文件信息，包括隐藏的文件，而ls -l只列出显式文件，说明这两个命令还是不等同的！&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git cherry-pick 命令介绍.&lt;/p&gt;

&lt;p&gt;简单来说：git cherry-pick用于把另一个本地分支的commit修改应用到当前分支。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;应用中,当开发在master分支时，而服务器运行的代码在server分支。这样当需要发布新版本时，需要首先到服务器端代码部分，执行以下命令，来使master分支代码到server分支，同时更新服务器端代码到最新。
&lt;code&gt;&lt;/p&gt;

&lt;h1 id=&#34;bin-sh:b7d8c5818853d24675f2be77c2ebb7c4&#34;&gt;/bin/sh&lt;/h1&gt;

&lt;p&gt;git checkout master
git pull
git checkout server
git cherry-pick master
&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建立一个新的代码库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ sudo git init --bare sample.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加新的用户,需要在.ssh/authorized_keys中添加用户的id_rsa.pub文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;go语言部分主要是hot部分。
42.62.2.62上的go服务分析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用go的beego框架，redis框架，和beego依赖的框架如mysql等，已经成功在本地运行。&lt;/li&gt;
&lt;li&gt;go语言使用的mysql是42.62.2.62的数据库，配置文件中直接配置的是本地，端口是默认的3306。
用户名密码有两个，一个是空密码的root，一个是weico3密码是ef86157.&lt;br/&gt;
go链接数据库的配置是一行 &lt;code&gt;weico3:ef86157@tcp(127.0.0.1:3306)/weico3_dev?charset=utf8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;42.62.2.62在DnsPod上映射的域名是weico3，二级域名是weico.cc。端口是go配置文件app.conf中的8080，
但是这部分并不能直接通过ip+端口来进行访问，在服务器42.62.2.62上，是通过nginx来进行分发处理的。&lt;/li&gt;
&lt;li&gt;查看nginx的配置文件（配置文件位置通过命令 nginx -t 来找到）。配置文件nginx.conf中引用了ttt.conf,
而ttt.conf文件开头的
&lt;code&gt;
upstream ttt{
server 127.0.0.1:8080;
}
&lt;/code&gt;
定义了一个负载均衡。
在server部分又监听80端口，定义了域名访问weico3.weico.cc,将所有请求&lt;code&gt;proxy_pass http://ttt;&lt;/code&gt;转给了ttt，完成了到go服务的请求&lt;/li&gt;
&lt;li&gt;个人猜测：数据库部分,go语言部分代码仅仅提供了对外的api，从数据库中读取数据；数据库的写入部分是weico_admin_v3部分来完成的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加ssh到服务器&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;实际使用的时候，其实就是将本地的id_rsa.pub添加到服务器的 authorized_keys 中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
# ssh-keygen -t rsa (连续三次回车,即在本地生成了公钥和私钥,不设置密码)
# ssh root@172.24.253.2 &#34;mkdir .ssh;chmod 0700 .ssh&#34; (需要输入密码)
# scp ~/.ssh/id_rsa.pub root@172.24.253.2:.ssh/id_rsa.pub (需要输入密码)
然后在B上的命令:
# touch /root/.ssh/authorized_keys (如果已经存在这个文件, 跳过这条)
# cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys (将id_rsa.pub的内容追加到 authorized_keys 中)
回到A机器:
# ssh root@172.24.253.2 (因为没有设置私钥密码, 所以不需要密码, 登录成功) &lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;部署weico3到服务器端，进行相关的处理
&lt;pre&gt;
//linux平台编译
GOOS=linux GOARCH=amd64 go build&lt;/p&gt;

&lt;p&gt;//上传新的包
scp -i ~/workspace/weico_rsa weico3 root@42.62.2.62:/mnt/tfs7/weico3/go/src/com.weico/weico3_new&lt;/p&gt;

&lt;p&gt;//杀掉weico3进程
kill -s 9 $1
//重命名
mv weico3 weico3_old
mv weico3_new weico3
chmod 777 weico3
//切换用户
su weico3
//不挂起启动
nohup ./weico3 &amp;amp;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;清理redis指定key的缓存&lt;/p&gt;

&lt;p&gt;删除所有weico开头的缓存 &lt;code&gt;redis-cli keys &amp;quot;weico*&amp;quot; | xargs redis-cli del&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;得到服务器的对外端口&lt;/p&gt;

&lt;p&gt;是否开启了21端口: &lt;code&gt;netstat -ntpl|grep 21&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;结果显示
&lt;code&gt;tcp6       0      0 :::21                   :::*                    LISTEN      27660/vsftpd&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git服务器地址迁移。&lt;/p&gt;

&lt;p&gt;迁移git服务器其实很简单，在新的服务器上初始化新的git包，或者直接将原来的git包复制过来即可。在客户端，需要修改一下remote地址&lt;/p&gt;

&lt;p&gt;新的服务器地址是&lt;code&gt;dev.weico.com&lt;/code&gt;，代码放在android用户目录下，最后拼装成新的git地址是:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone root@dev.weico.com:/home/android/WeicoTV.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在本地项目目录下，首先移除原来的remote地址:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git remote remove origin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后添加新的remote地址:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git remote add origin root@dev.weico.com:/home/android/WeicoTV.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重新push一下即可，这样会将本地所有的修改提交到新的服务器上。（服务器端采用复制git包或者重新初始化git包的方式，都可以将代码更新成最新的）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>尝试研究自己的flux架构</title>
      <link>http://qihigh.github.io/android/flux_study/</link>
      <pubDate>Mon, 26 Oct 2015 15:32:19 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/flux_study/</guid>
      <description>&lt;p&gt;###事件通知&lt;/p&gt;

&lt;p&gt;flux架构依赖于事件通知框架，这里使用的是EventBus，也可以采用otto。（如果不采用事件通知框架的话，会需要activity实现回调接口，这样的话侵入性较大，单元测试也不好写）&lt;/p&gt;

&lt;p&gt;研究eventBus的使用的时候，因为otto一般都是在onStart和onPause进行事件的注册和取消注册，但是在使用eventBus的时候发现，如果在onStart和onPause的时候进行事件注册，会丢失掉第一个事件，所以还是换成了onCreate和onDestory的时候进行事件的注册和取消注册。&lt;/p&gt;

&lt;p&gt;###store的可靠性&lt;/p&gt;

&lt;p&gt;flux架构依赖于store的数据可靠性，所以需要对有可能造成数据不可靠的情况进行特殊处理。一般的，这种情况容易出现在ListView显示的时候，store里的List集合被频繁更改导致的数据不同步。这里采用loadMore的方式，会触发数据集合的增长变化，来定位引发数据不同步的步骤，这里有两个值得怀疑的步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Api网络密集请求，在回调中频繁更新数据。&lt;/li&gt;
&lt;li&gt;事件通知框架有延迟，导致数据更新了而通知未到达。&lt;/li&gt;
&lt;li&gt;ListView中itemView渲染速度慢导致刷新问题（已验证，在View中添加耗时操作，界面卡顿，但不会出现异常）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过实际尝试，发现循环10次调用之后，步骤1会导致数据不同步，而步骤2没有出现异常。说明事件通知框架在数据密集请求的情况下是可靠地。&lt;/p&gt;

&lt;p&gt;###单元测试尝试&lt;/p&gt;

&lt;p&gt;flux架构一个特点就是方便测试，因为数据是单向的，事件的开始是调用action中的一个方法，最后一步数据的流向是通过EventBus来控制的，所以当做单元测试的时候，并不需要依赖activity，直接调用一个方法，然后注册一个Event监听，就能方便的完成单元测试。&lt;/p&gt;

&lt;p&gt;当然，由于数据有可能是网络请求，单元测试的过程中需要进行等待网络请求完成才能继续向下，这里采用了一个简单的锁机制，阻塞单元测试在网络请求完成之前不退出。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一种锁是AtomBoolean，是最初想到的方案，并且写在setUp和tearDown中，用起来很方便。&lt;/li&gt;
&lt;li&gt;现在采用的是BlockingQueue，这个是现在用的比较多的类，不过这里之所以采用他，是因为他和go语言中的锁机制是相同的，从大体上来看，更容易理解，使用起来比原子操作也简单。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;运行单元测试有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接在类的右键中运行单元测试，有特定的UI界面，比较友好，适合单个的单元测试。&lt;/li&gt;
&lt;li&gt;在命令行输入命令 &lt;code&gt;./gradlew connectedCheck&lt;/code&gt; ，适合运行所有单元测试。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>小米状态栏颜色</title>
      <link>http://qihigh.github.io/android/xiaomi_statusbar/</link>
      <pubDate>Mon, 26 Oct 2015 15:30:20 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/xiaomi_statusbar/</guid>
      <description>&lt;p&gt;小米的系统，最上方的状态栏是没有任何背景颜色的，当切换主题的时候就会遇到问题。当系统是白色的时候，如果切换到一个白色背景的主题，会导致上边状态栏的内容是分辨不出来的。（魅族的状态栏也没有颜色，但是他会根据当前背景，自动更新颜色，所以没有这个问题）&lt;/p&gt;

&lt;p&gt;这里通过反射的方式寻得了仅针对小米系统的一个解决方案:&lt;/p&gt;

&lt;pre&gt;
/**
 * 判断是否是小米，如果是的话，通过反射的方式，修改状态栏模式。
 * @param window
 */
public static void statusBar(Window window) {
    Boolean blackbg = Res.getBoolean(R.bool.isPop);
    Class clazz = window.getClass();
    try {
        int tranceFlag = 0;
        int darkModeFlag = 0;
        Class layoutParams = Class.forName(&#34;android.view.MiuiWindowManager$LayoutParams&#34;);

        Field field = layoutParams.getField(&#34;EXTRA_FLAG_STATUS_BAR_TRANSPARENT&#34;);
        tranceFlag = field.getInt(layoutParams);

        field = layoutParams.getField(&#34;EXTRA_FLAG_STATUS_BAR_DARK_MODE&#34;);
        darkModeFlag = field.getInt(layoutParams);

        Method extraFlagField = clazz.getMethod(&#34;setExtraFlags&#34;, int.class, int.class);

        extraFlagField.invoke(window, blackbg ? tranceFlag : darkModeFlag, blackbg ? tranceFlag : darkModeFlag);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>android start</title>
      <link>http://qihigh.github.io/android/start/</link>
      <pubDate>Mon, 26 Oct 2015 15:13:03 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/start/</guid>
      <description>&lt;p&gt;android相关&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>