<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>QiHuan</title>
    <link>http://qihigh.github.io/</link>
    <description>Recent content on QiHuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Oct 2015 15:40:55 +0800</lastBuildDate>
    <atom:link href="http://qihigh.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>后端交接文档</title>
      <link>http://qihigh.github.io/back/backyield/</link>
      <pubDate>Mon, 26 Oct 2015 15:40:55 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/backyield/</guid>
      <description>&lt;pre&gt;

账号：

1、监控宝
http://www.jiankongbao.com

weicolomo@gmail.com     weico+lomo  -&gt; weico+lomo_
canon@3ciyuan.com     xinciyuan123【已弃用】
dev@weico.com       kUBZiiwEh3Bie8   -&gt; kUBZiiwEh3Bie8_

2、snmp v3（所有机器）
weico     8899//==we

3、UCloud
dev@eicodesign.com
dev@5YxbNTdbMP  -&gt; dev@5YxbNTdbMP_

更新为
    qihuan@weico.com
    weico2014++

4、DNSPod
info@eicodesign.com  // weico.com weico.net
9ol.=[;.        -&gt; 9ol.=[;._
weico@eicodesign.com // weico.cc weicopl.us
9ol.=[;.        -&gt; 9ol.=[;._
likan@eicodesign.com
9ol.=[;.        -&gt; 9ol.=[;.=

5、花生壳
weicodev/1q2w3e4r  -&gt; 1q2w3e4r_
                   -&gt; 1q2w3e4r

6 Linode    --- 
用户名: 1982870, 密码: 1982870123a
ssh root@106.185.52.238 -p 1010
Cec+Pav&gt;kelv&gt;iD%

7 Jenkins
http://weicodev.wicp.net:9090/
http://192.168.1.80:8080/
username: weico
password: fU$ij+Mod:aD]jaR

8 weico.com邮箱管理帐号
ym.163.com
admin@weico.com / OLuJRaDe51qQ  //error password

9. WeicoBUG跟踪系统

http://192.168.1.80/bugzilla/ （内网）
http://weicodev.wicp.net:8080/bugzilla/
dev@weico.com
1123581321



联系方式：

800083103     广东锐讯网络有限公司
1171533501     森华 销售 看丹桥-梁爽
938060261      森华 看丹桥
712957909     美国机房
2880269152     锐讯-周鸿升
609509091     李侃推荐 服务器-DELL-聂伟


服务器列表：

ssh deployer@42.62.2.50 - 
主要是weico的好友数据库，以及postgres地理位置数据，基本不用特别维护

ssh deployer@42.62.2.51 - 
1. 新的小游戏平台weicogame服务（包括后端API以及前端服务）
2. 方糖相机资源管理API服务
3. 方糖相机，下载跳转jumper服务
4. 方糖相机用户数据上报服务
5. meShot资源管理 ResourceManager

ssh deployer@42.62.2.58  - 
1. 微可拍API /home/deployer/developer/weicoplus (编译后的)
2. Pinco服务
3. Pinco的Tag搜索服务
4. weico api服务

ssh deployer@42.62.2.59  - 
1. 微可拍粉丝数据SSDB

ssh deployer@42.62.2.60 -
1. 文件存储服务器

ssh deployer@42.62.2.61 -
1. 微可拍好友动态数据SSDB

ssh deployer@42.62.2.62 -
1. weico3 数据库

ssh weico3@42.62.2.62
1. weico3 服务 (ssh weico3@42.62.2.62)
     文件位置：/mnt/tfs7/weico3/go/src/com.weico/weico3 
     项目地址：git@weicodev.vicp.cc:/mnt/data/repo/weico_server_go_v3.git

ssh deployer@118.26.233.56 -
1. 微可拍老接口 （/home/deployer/project/weicolomo/）
2. 微可拍用户接口 （/home/deployer/project/profile/）
3. 微可拍接口 （/home/deployer/androidtest/weicolomo）
4. 微可拍辅库
5. Redis服务（weico_user_q定时删除）

ssh deployer@118.26.233.57
1. 微可拍主库

ssh deployer@118.26.225.125
1. weico.com/eicodesign.com等官网
2. 数据库访问 mysql -h 127.0.0.1 -uroot
3. eico的用户管理erp http://118.26.225.125:8087/

ssh deployer@119.147.137.69
ssh deployer@119.90.40.250

ssh ubuntu@120.132.54.51
1. weiconote国内服务器
su: note@weico2014++
 ip更新为 120.132.56.18
 sudo weico2014++
 sudo -i 切换为root用户

ssh deployer@106.185.52.238 -p 1010
1. weiconote海外服务器地址（oversea, japan, korean）
     项目路径 /home/deployer/developer/workspace/src/com.weico
2. redis服務 redis-cli
3. mysql服务 mysql -uroot -proot




常见错误处理：
1. 服务器硬盘快满了
cd /usr/local/nginx/logs/  或者
cd /usr/local/tengine/logs
cp /dev/null 比较大的日志.log

2. 118.26.233.56 的mysql主从备份出错
https://alexzeng.wordpress.com/2013/10/17/how-to-fix-mysql-slave-after-relay-log-corrupted/

mysql -uroot -proot

show slave status\G;

stop slave;

CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000737&#39;, MASTER_LOG_POS=625032890;

start slave;

3. weico+服务无法访问，先查看42.62.2.58上的10010端口的revel 服务是否正常运行，没有则运行 revel run com.weico/weicoplus prod 10010
如果服务正常运行，则查看是不是日志满了

4.  42.62.2.51服务器添加服务端口
     firewall-cmd --permanent --zone=public --add-port=10020/tcp
     firewall-cmd --reload


5. 海蜘蛛路由器密码
    路由器管理地址：http://10.0.1.254:880/
    管理页面登陆账号:admin - r3i2ojS_dcjir4f
    路由器拨号账号：
        1. 010010017063 - 731792
        2. 010999009413  - 暂未重置

&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>DNS域名绑定</title>
      <link>http://qihigh.github.io/back/dns_bind/</link>
      <pubDate>Mon, 26 Oct 2015 15:40:23 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/dns_bind/</guid>
      <description>

&lt;p&gt;首先域名绑定需要的几个基础概念:&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;a-address-记录:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;A(Address)记录&lt;/h4&gt;

&lt;p&gt;是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。&lt;/p&gt;

&lt;h4 id=&#34;cname:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;CNAME&lt;/h4&gt;

&lt;p&gt;也被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。 这两个别名的全称就是“www.mydomain.com”和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。 同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP然后将其他的域名做别名到之前做A记录的域名上，那么当您的服务器IP地址变更时您就可以不必麻烦的一个一个域名更改指向了 只需要更改做A记录的那个域名其他做别名的那些域名的指向也将自动更改到新的IP地址上了。&lt;/p&gt;

&lt;h4 id=&#34;ttl:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;TTL&lt;/h4&gt;

&lt;p&gt;TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间。要理解TTL值，请先看下面的一个例子： 假设，有这样一个域名myhost.cnMonkey.com（其实，这就是一条DNS记录，通常表示在abc.com域中有一台名为myhost的主机）对应IP地 址为1.1.1.1，它的TTL为10分钟。这个域名或称这条记录存储在一台名为dns.cnMonkey.com的DNS服务器上。 现在有一个用户键入一下地址（又称URL）：&lt;a href=&#34;http://myhost.cnMonkey.com&#34;&gt;http://myhost.cnMonkey.com&lt;/a&gt; 这时会发生什么呢？ 该 访问者指定的DNS服务器（或是他的ISP,互联网服务商, 动态分配给他的)8.8.8.8就会试图为他解释myhost.cnMonkey.com，当然8.8.8.8这台DNS服务器由于没有包含 myhost.cnMonkey.com这条信息，因此无法立即解析，但是通过全球DNS的递归查询后，最终定位到dns.cnMonkey.com这台DNS服务器， dns.cnMonkey.com这台DNS服务器将myhost.cnMonkey.com对应的IP地址1.1.1.1告诉8.8.8.8这台DNS服务器，然有再由 8.8.8.8告诉用户结果。8.8.8.8为了以后加快对myhost.cnMonkey.com这条记录的解析，就将刚才的1.1.1.1结果保留一段时间，这 就是TTL时间，在这段时间内如果用户又有对myhost.cnMonkey.com这条记录的解析请求，它就直接告诉用户1.1.1.1，当TTL到期则又会重复 上面的过程。&lt;/p&gt;

&lt;h4 id=&#34;域名分级:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;域名分级&lt;/h4&gt;

&lt;p&gt;子域名是个相对的概念，是相对父域名来说的。域名有很多级，中间用点分开。例如中国国家顶级域名CN，所有以 CN 结尾的域名便都是它的子域。例如：www.zzy.cn 便是 zzy.cn 的子域，而 zzy.cn 是 cn 的子域。&lt;/p&gt;

&lt;p&gt;“二级域名”：目前有很多用户认为“二级域名”是自己所注册域名的下一级域名，实际上这里所谓的“二级域名”并非真正的“二级”，而应该称为“次级”(相对次级)&lt;/p&gt;

&lt;p&gt;例如您注册的域名是abc.cn来说：CN为顶级域，abc.cn为二级域，www.abc.cn、mail.abc.cn、help.zzy.cn为三级域。&lt;/p&gt;

&lt;p&gt;还有一些特殊的二级域被用来作顶级域使用，例如：com.cn、net.cn、org.cn、gov.cn（包括地区域名bj.cn、fj.cn等）。那么此时用户所注册的就应该是三级域了，例如114.com.cn。（备注：www.gov.cn实际上是以gov.cn为后缀的www域名，就是说如果您在域名Whois信息查询中输入gov.cn是查询不到注册信息的因为gov.cn是作为顶级域来使用的域名后缀，真正开放注册的是www.gov.cn）。然而当前有很多用户还是习惯地将可以允许用户注册的域名称为顶级域名，而所注册域名的下一级域名称为“二级域名”，其实从严格意义上来讲这是不对的，所以我们前面会说“子域名”、“二级域名”是相对的概念，准确的应该称为“次级域名”。&lt;/p&gt;

&lt;h4 id=&#34;域名购买:d06e56ff85adba84c80dd7fa0b4917ef&#34;&gt;域名购买&lt;/h4&gt;

&lt;p&gt;众所周知，域名是要购买的，国内用域名访问主机大概是要备案的，有些麻烦。所以现在很多人从国外的域名注册商那儿买域名，比如goddady。如果是新手想在国外买域名的话，最好准备一张VISA信用卡，并用paypal来支付（可以省手续费）。goddady现在也支持支付宝，支付起来也很方便。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;接下来介绍weico在DNSPod上购买的域名处理方式。
在weico.cc域名下得记录管理中，有添加的很多记录，这里首先是默认的三个@记录，这是默认的记录，不用管。
接下来列表中还有很多，比如abc对应的记录：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主机记录:abc    &amp;ndash;表示的是主机的三级域名&lt;/li&gt;
&lt;li&gt;记录类型:A    &amp;ndash;表示的是A类记录&lt;/li&gt;
&lt;li&gt;线路类型:默认   &amp;ndash;这里也包含海外和国内&lt;/li&gt;
&lt;li&gt;记录值:42.62.2.51    &amp;ndash;域名对应的ip地址&lt;/li&gt;
&lt;li&gt;TTl:120       &amp;ndash;过期时间，这里是两分钟&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这里，尝试ping 42.62.2.51 是可以ping通的，abc加上二级域名weico.cc，组成abc.weico.cc，这个应该也是可以ping通的。&lt;/p&gt;

&lt;p&gt;印证一下
uploadify的地址是 &lt;a href=&#34;http://118.26.225.125:8006/index，&#34;&gt;http://118.26.225.125:8006/index，&lt;/a&gt;
在记录值中找到对应这个ip的有几条记录，这里选用weicofile这个三级域名，将地址更新为 &lt;a href=&#34;http://weicofile.weico.cc:8006/index，&#34;&gt;http://weicofile.weico.cc:8006/index，&lt;/a&gt; 发现访问的结果是相同的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>adb识别新的usb连接</title>
      <link>http://qihigh.github.io/android/usb_adb/</link>
      <pubDate>Mon, 26 Oct 2015 15:39:24 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/usb_adb/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;当有一个新的Android设备想要连接电脑时，如果识别不了，则需要主动将该设备的设备码id添加到abd_usb.ini的配置文件中。接下来介绍的是如何查找新设备的设备码。
&lt;pre&gt;
//mac下对应的命令
system_profiler SPUSBDataType &amp;gt; ~/usb.txt  &lt;/pre&gt;
打开文件usb.txt，在最后的&lt;code&gt;USB Hi-Speed Bus: -&amp;gt; Hub -&amp;gt; Android&lt;/code&gt;可以找到这个Android的条目，其中的&lt;code&gt;Vendor ID: 0x2a70&lt;/code&gt;就是对应的id，追加到&lt;code&gt;echo 0x2a70 &amp;gt;&amp;gt; ~/.android/adb_usb.ini&lt;/code&gt;中即可。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>blog生成命令相关</title>
      <link>http://qihigh.github.io/back/blog_generate/</link>
      <pubDate>Mon, 26 Oct 2015 15:34:59 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/blog_generate/</guid>
      <description>

&lt;h3 id=&#34;jekyll-方式:53ce08bd8daefb24173b0a5b1246e436&#34;&gt;jekyll 方式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新建一篇可以进行评论的文章&lt;code&gt;rake post title=&amp;quot;nginx study&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行blog的命令
&lt;code&gt;
    jekyll serve
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hugo-方式:53ce08bd8daefb24173b0a5b1246e436&#34;&gt;hugo 方式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新建一个侧边栏&lt;/p&gt;

&lt;p&gt;在config.yaml中添加一个新的links就可以&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新建一篇文章&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new android/new.md&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行服务&lt;/p&gt;

&lt;p&gt;实时更新方式（当进行修改之后，后台会发通知给浏览器，浏览器自动更新，不需要手动刷新）
&lt;code&gt;hugo server --theme=herring-cove --buildDrafts --watch&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>学习nginx的安装、配置</title>
      <link>http://qihigh.github.io/back/nginx_study/</link>
      <pubDate>Mon, 26 Oct 2015 15:34:15 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/nginx_study/</guid>
      <description>

&lt;h4 id=&#34;nginx的本地安装:1da1b7d5c01ab3bac077892a9b3f8ca3&#34;&gt;nginx的本地安装&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先是要在本地安装一个nginx服务器，来看看最基本的nginx是神马样子的。安装方式并不复杂，而且nginx完全是通过c来编写的，依赖并不多，整个服务器才不到1Mb。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;特殊的，nginx是有很多第三方包的，而且实际调试使用时基本是必须的，如果一个一个安装显得过于繁琐，这里有一个配置好了各个常用插件的nginx的版本：openresty,下载下来进行安装即可。mac下需要首先安装&lt;code&gt;PCRE&lt;/code&gt;，然后通过
&lt;pre&gt;
$ ./configure \
         &amp;ndash;with-cc-opt=&amp;ldquo;-I/usr/local/include&amp;rdquo; \
         &amp;ndash;with-ld-opt=&amp;ldquo;-L/usr/local/lib&amp;rdquo; \ &lt;/pre&gt;
进行配置，然后通过&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt; 进行安装&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;本地运行环境是mac，需要安装一个perl的正则解析PCRE
&lt;pre&gt;
$ cd ~/Downloads
$ tar xvzf pcre-8.5
$ cd pcre-8.5
$ sudo ./configure &amp;ndash;prefix=/usr/local
$ sudo make
$ sudo make install &lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后安装nginx
&lt;pre&gt;
$ cd ~/Downloads
$ tar xvzf nginx-1.6.0.tar.gz
$ cd nginx-1.6.0
$ sudo ./configure &amp;ndash;prefix=/usr/local/nginx &amp;ndash;with-http_ssl_module &amp;ndash;with-cc-opt=&amp;ldquo;-Wno-deprecated-declarations&amp;rdquo;
$ sudo make
$ sudo make install &lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尝试启动nginx，
&lt;pre&gt;
$ cd /usr/local/nginx/sbin
$ sudo ./nginx  &lt;/pre&gt;
然后访问&lt;code&gt;localhost&lt;/code&gt;,如果页面显示&lt;code&gt;Welcome to nginx!&lt;/code&gt;,则说明nginx安装成功并成功启动。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;停止nginx
&lt;pre&gt;
sudo ./nginx -s stop    &lt;/pre&gt;
之后可以将nginx加入到path中去。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果nginx停止失败，可以通过kill命令来通知nginx停止&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先查看nginx运行的情况 &lt;code&gt;ps -ef|grep nginx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找到master进程，它的编号就是主进程号了，通过 &lt;code&gt;sudo kill -QUIT 8339 将其杀掉&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改了配置文件，首先校验配置文件是否正确
&lt;pre&gt;
nginx -t -c nginx.conf
或者
nginx -t &lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不重启nginx，应用新的配置文件.（首先要使用步骤7校验配置文件）
&lt;pre&gt;
nginx -s reload &lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Mysql导出表结构及表数据 mysqldump用法</title>
      <link>http://qihigh.github.io/back/mysql_dump/</link>
      <pubDate>Mon, 26 Oct 2015 15:33:46 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/mysql_dump/</guid>
      <description>

&lt;h4 id=&#34;命令行下具体用法如下:21b917757f8ba675c9e9b05b2ed32895&#34;&gt;命令行下具体用法如下：&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;mysqldump -u用戶名 -p密码 -d 数据库名 表名 脚本名;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;导出数据库為dbname的表结构（其中用戶名為root,密码為dbpasswd,生成的脚本名為db.sql）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysqldump -uroot -pdbpasswd -d dbname &amp;gt;db.sql;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导出数据库為dbname某张表(test)结构&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysqldump -uroot -pdbpasswd -d dbname test&amp;gt;db.sql;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导出数据库為dbname所有表结构及表數據（不加-d）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysqldump -uroot -pdbpasswd  dbname &amp;gt;db.sql;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导出数据库為dbname某张表(test)结构及表數據（不加-d）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysqldump -uroot -pdbpasswd dbname test&amp;gt;db.sql;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;其他数据库相关:21b917757f8ba675c9e9b05b2ed32895&#34;&gt;其他数据库相关&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;查看MySQL端口号：```show global variables like &#39;port&#39;;  ```
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>后台经验</title>
      <link>http://qihigh.github.io/back/yield_experience/</link>
      <pubDate>Mon, 26 Oct 2015 15:33:12 +0800</pubDate>
      
      <guid>http://qihigh.github.io/back/yield_experience/</guid>
      <description>

&lt;p&gt;###ssh
使用天宇发过来的rsa进行登录
&lt;code&gt;ssh -i ~/.ssh/weico_rsa root@xxx.xxx.xxx.xxx&lt;/code&gt;
chmod 600 weico_rsa 你要改下权限&lt;/p&gt;

&lt;p&gt;###服务器
1.  Linode&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ssh -i ~/workspace/weico_rsa root@106.185.52.238 -p 1010&lt;/code&gt;
        weiconote海外&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###工具&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;压缩命令 tar&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;压缩muma_web，文件名为web.tar.gz，压缩方式为gzip
&lt;code&gt;tar -czvf web.tar.gz muma_web&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;复制命令&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本地到远程
&lt;code&gt;
scp -i ~/workspace/weico_rsa temp.txt deployer@42.62.2.58:/home/deployer/temp.txt
&lt;/code&gt;
颠倒一下 远程到本地
&lt;code&gt;
scp -i ~/workspace/weico_rsa deployer@42.62.2.58:/home/deployer/temp.txt 1.txt
&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ssh服务器端&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;弄个ssh-copy-id
&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub user@server&lt;/code&gt;
类似这样，把你的key全部加一下&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ps查看所有用户运行的程序，和top类似，但是只查看一瞬间&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;
[weico3@localhost project]$ ps aux|grep deployer
deployer  5786  0.0  0.0 108460  1008 pts/2    Ss+  Jul06   0:00 -bash
deployer  6427  0.0  0.0  28916  1256 ?        Ss   Mar09  68:08 tmux new -s devel
deployer  6428  0.0  0.0 108460     0 pts/7    Ss   Mar09   0:00 -bash
deployer  6445  0.0  0.0 199840   104 pts/7    S+   Mar09   0:00 mysql -uroot
weico3   13004  0.0  0.0 103260   592 pts/1    S+   15:50   0:00 grep deployer
    &lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mysql -uroot -p是什么命令&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个是登mysql登陆数据库的命令，如果你使用黑窗口(DOS)的话就要这个命令进入数据库。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ll 命令&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ll 命令列出的信息更加详细，有时间，是否可读写等信息 , 和ls相比，ll会列出该文件下的所有文件信息，包括隐藏的文件，而ls -l只列出显式文件，说明这两个命令还是不等同的！&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git cherry-pick 命令介绍.&lt;/p&gt;

&lt;p&gt;简单来说：git cherry-pick用于把另一个本地分支的commit修改应用到当前分支。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;应用中,当开发在master分支时，而服务器运行的代码在server分支。这样当需要发布新版本时，需要首先到服务器端代码部分，执行以下命令，来使master分支代码到server分支，同时更新服务器端代码到最新。
&lt;code&gt;&lt;/p&gt;

&lt;h1 id=&#34;bin-sh:b7d8c5818853d24675f2be77c2ebb7c4&#34;&gt;/bin/sh&lt;/h1&gt;

&lt;p&gt;git checkout master
git pull
git checkout server
git cherry-pick master
&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建立一个新的代码库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ sudo git init --bare sample.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加新的用户,需要在.ssh/authorized_keys中添加用户的id_rsa.pub文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;go语言部分主要是hot部分。
42.62.2.62上的go服务分析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用go的beego框架，redis框架，和beego依赖的框架如mysql等，已经成功在本地运行。&lt;/li&gt;
&lt;li&gt;go语言使用的mysql是42.62.2.62的数据库，配置文件中直接配置的是本地，端口是默认的3306。
用户名密码有两个，一个是空密码的root，一个是weico3密码是ef86157.&lt;br/&gt;
go链接数据库的配置是一行 &lt;code&gt;weico3:ef86157@tcp(127.0.0.1:3306)/weico3_dev?charset=utf8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;42.62.2.62在DnsPod上映射的域名是weico3，二级域名是weico.cc。端口是go配置文件app.conf中的8080，
但是这部分并不能直接通过ip+端口来进行访问，在服务器42.62.2.62上，是通过nginx来进行分发处理的。&lt;/li&gt;
&lt;li&gt;查看nginx的配置文件（配置文件位置通过命令 nginx -t 来找到）。配置文件nginx.conf中引用了ttt.conf,
而ttt.conf文件开头的
&lt;code&gt;
upstream ttt{
server 127.0.0.1:8080;
}
&lt;/code&gt;
定义了一个负载均衡。
在server部分又监听80端口，定义了域名访问weico3.weico.cc,将所有请求&lt;code&gt;proxy_pass http://ttt;&lt;/code&gt;转给了ttt，完成了到go服务的请求&lt;/li&gt;
&lt;li&gt;个人猜测：数据库部分,go语言部分代码仅仅提供了对外的api，从数据库中读取数据；数据库的写入部分是weico_admin_v3部分来完成的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加ssh到服务器&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;实际使用的时候，其实就是将本地的id_rsa.pub添加到服务器的 authorized_keys 中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
# ssh-keygen -t rsa (连续三次回车,即在本地生成了公钥和私钥,不设置密码)
# ssh root@172.24.253.2 &#34;mkdir .ssh;chmod 0700 .ssh&#34; (需要输入密码)
# scp ~/.ssh/id_rsa.pub root@172.24.253.2:.ssh/id_rsa.pub (需要输入密码)
然后在B上的命令:
# touch /root/.ssh/authorized_keys (如果已经存在这个文件, 跳过这条)
# cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys (将id_rsa.pub的内容追加到 authorized_keys 中)
回到A机器:
# ssh root@172.24.253.2 (因为没有设置私钥密码, 所以不需要密码, 登录成功) &lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;部署weico3到服务器端，进行相关的处理
&lt;pre&gt;
//linux平台编译
GOOS=linux GOARCH=amd64 go build&lt;/p&gt;

&lt;p&gt;//上传新的包
scp -i ~/workspace/weico_rsa weico3 root@42.62.2.62:/mnt/tfs7/weico3/go/src/com.weico/weico3_new&lt;/p&gt;

&lt;p&gt;//杀掉weico3进程
kill -s 9 $1
//重命名
mv weico3 weico3_old
mv weico3_new weico3
chmod 777 weico3
//切换用户
su weico3
//不挂起启动
nohup ./weico3 &amp;amp;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;清理redis指定key的缓存&lt;/p&gt;

&lt;p&gt;删除所有weico开头的缓存 &lt;code&gt;redis-cli keys &amp;quot;weico*&amp;quot; | xargs redis-cli del&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;得到服务器的对外端口&lt;/p&gt;

&lt;p&gt;是否开启了21端口: &lt;code&gt;netstat -ntpl|grep 21&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;结果显示
&lt;code&gt;tcp6       0      0 :::21                   :::*                    LISTEN      27660/vsftpd&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git服务器地址迁移。&lt;/p&gt;

&lt;p&gt;迁移git服务器其实很简单，在新的服务器上初始化新的git包，或者直接将原来的git包复制过来即可。在客户端，需要修改一下remote地址&lt;/p&gt;

&lt;p&gt;新的服务器地址是&lt;code&gt;dev.weico.com&lt;/code&gt;，代码放在android用户目录下，最后拼装成新的git地址是:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone root@dev.weico.com:/home/android/WeicoTV.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在本地项目目录下，首先移除原来的remote地址:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git remote remove origin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后添加新的remote地址:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git remote add origin root@dev.weico.com:/home/android/WeicoTV.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重新push一下即可，这样会将本地所有的修改提交到新的服务器上。（服务器端采用复制git包或者重新初始化git包的方式，都可以将代码更新成最新的）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>尝试研究自己的flux架构</title>
      <link>http://qihigh.github.io/android/flux_study/</link>
      <pubDate>Mon, 26 Oct 2015 15:32:19 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/flux_study/</guid>
      <description>&lt;p&gt;###事件通知&lt;/p&gt;

&lt;p&gt;flux架构依赖于事件通知框架，这里使用的是EventBus，也可以采用otto。（如果不采用事件通知框架的话，会需要activity实现回调接口，这样的话侵入性较大，单元测试也不好写）&lt;/p&gt;

&lt;p&gt;研究eventBus的使用的时候，因为otto一般都是在onStart和onPause进行事件的注册和取消注册，但是在使用eventBus的时候发现，如果在onStart和onPause的时候进行事件注册，会丢失掉第一个事件，所以还是换成了onCreate和onDestory的时候进行事件的注册和取消注册。&lt;/p&gt;

&lt;p&gt;###store的可靠性&lt;/p&gt;

&lt;p&gt;flux架构依赖于store的数据可靠性，所以需要对有可能造成数据不可靠的情况进行特殊处理。一般的，这种情况容易出现在ListView显示的时候，store里的List集合被频繁更改导致的数据不同步。这里采用loadMore的方式，会触发数据集合的增长变化，来定位引发数据不同步的步骤，这里有两个值得怀疑的步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Api网络密集请求，在回调中频繁更新数据。&lt;/li&gt;
&lt;li&gt;事件通知框架有延迟，导致数据更新了而通知未到达。&lt;/li&gt;
&lt;li&gt;ListView中itemView渲染速度慢导致刷新问题（已验证，在View中添加耗时操作，界面卡顿，但不会出现异常）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过实际尝试，发现循环10次调用之后，步骤1会导致数据不同步，而步骤2没有出现异常。说明事件通知框架在数据密集请求的情况下是可靠地。&lt;/p&gt;

&lt;p&gt;###单元测试尝试&lt;/p&gt;

&lt;p&gt;flux架构一个特点就是方便测试，因为数据是单向的，事件的开始是调用action中的一个方法，最后一步数据的流向是通过EventBus来控制的，所以当做单元测试的时候，并不需要依赖activity，直接调用一个方法，然后注册一个Event监听，就能方便的完成单元测试。&lt;/p&gt;

&lt;p&gt;当然，由于数据有可能是网络请求，单元测试的过程中需要进行等待网络请求完成才能继续向下，这里采用了一个简单的锁机制，阻塞单元测试在网络请求完成之前不退出。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一种锁是AtomBoolean，是最初想到的方案，并且写在setUp和tearDown中，用起来很方便。&lt;/li&gt;
&lt;li&gt;现在采用的是BlockingQueue，这个是现在用的比较多的类，不过这里之所以采用他，是因为他和go语言中的锁机制是相同的，从大体上来看，更容易理解，使用起来比原子操作也简单。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;运行单元测试有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接在类的右键中运行单元测试，有特定的UI界面，比较友好，适合单个的单元测试。&lt;/li&gt;
&lt;li&gt;在命令行输入命令 &lt;code&gt;./gradlew connectedCheck&lt;/code&gt; ，适合运行所有单元测试。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>小米状态栏颜色</title>
      <link>http://qihigh.github.io/android/xiaomi_statusbar/</link>
      <pubDate>Mon, 26 Oct 2015 15:30:20 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/xiaomi_statusbar/</guid>
      <description>&lt;p&gt;小米的系统，最上方的状态栏是没有任何背景颜色的，当切换主题的时候就会遇到问题。当系统是白色的时候，如果切换到一个白色背景的主题，会导致上边状态栏的内容是分辨不出来的。（魅族的状态栏也没有颜色，但是他会根据当前背景，自动更新颜色，所以没有这个问题）&lt;/p&gt;

&lt;p&gt;这里通过反射的方式寻得了仅针对小米系统的一个解决方案:&lt;/p&gt;

&lt;pre&gt;
/**
 * 判断是否是小米，如果是的话，通过反射的方式，修改状态栏模式。
 * @param window
 */
public static void statusBar(Window window) {
    Boolean blackbg = Res.getBoolean(R.bool.isPop);
    Class clazz = window.getClass();
    try {
        int tranceFlag = 0;
        int darkModeFlag = 0;
        Class layoutParams = Class.forName(&#34;android.view.MiuiWindowManager$LayoutParams&#34;);

        Field field = layoutParams.getField(&#34;EXTRA_FLAG_STATUS_BAR_TRANSPARENT&#34;);
        tranceFlag = field.getInt(layoutParams);

        field = layoutParams.getField(&#34;EXTRA_FLAG_STATUS_BAR_DARK_MODE&#34;);
        darkModeFlag = field.getInt(layoutParams);

        Method extraFlagField = clazz.getMethod(&#34;setExtraFlags&#34;, int.class, int.class);

        extraFlagField.invoke(window, blackbg ? tranceFlag : darkModeFlag, blackbg ? tranceFlag : darkModeFlag);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>android start</title>
      <link>http://qihigh.github.io/android/start/</link>
      <pubDate>Mon, 26 Oct 2015 15:13:03 +0800</pubDate>
      
      <guid>http://qihigh.github.io/android/start/</guid>
      <description>&lt;p&gt;android相关&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>http://qihigh.github.io/about/</link>
      <pubDate>Mon, 26 Oct 2015 15:11:13 +0800</pubDate>
      
      <guid>http://qihigh.github.io/about/</guid>
      <description>&lt;p&gt;自我介绍&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>